/*
	Highly divisible triangular number

	The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

		1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

	Let us list the factors of the first seven triangle numbers:

		 1: 1
		 3: 1,3
		 6: 1,2,3,6
		10: 1,2,5,10
		15: 1,3,5,15
		21: 1,3,7,21
		28: 1,2,4,7,14,28

	We can see that 28 is the first triangle number to have over five divisors.

	What is the value of the first triangle number to have over five hundred divisors?
 */

var utils = require('lib/utils.js');
var factors = require('lib/factors.js');
var primes = require('lib/primes.js');

var self = module.exports = {
	problemNumber: 12,
	description: 'First triangle number to have over five hundred divisors',
	answer: 76576500,
	given: [500],
	solutions: {
		'prime factorization': {
			fn: function(numDivisors) {
				var count, num = 1, i = 2;
				// loop through triangle numbers
				while ((count = factors.countFactors(num)) <= numDivisors) {
					num += i++;
				}
				return num;
			}
		},
		'prime factorization optimization using rough lower bound': {
			fn: function(numDivisors) {
				var halfNumDivisors = numDivisors / 2;
				var lowerBound = Math.ceil(halfNumDivisors) * Math.floor(halfNumDivisors + 1);
				var closestIndex = Math.floor((Math.sqrt(1 + 8 * lowerBound) - 1) / 2); // quadratic formula
				lowerBound = (closestIndex * (closestIndex + 1)) / 2;
				var count, num = lowerBound, i = closestIndex + 1;
				// loop through triangle numbers
				while ((count = factors.countFactors(num)) <= numDivisors) {
					num += i++;
				}
				return num;
			}
		},
		'prime factorization optimization using lower bound': {
			fn: function(numDivisors) {
				var lowerBound = factors.smallestNumberWithNFactors(numDivisors);
				var closestIndex = Math.floor((Math.sqrt(1 + 8 * lowerBound) - 1) / 2); // quadratic formula
				lowerBound = (closestIndex * (closestIndex + 1)) / 2;
				var count, num = lowerBound, i = closestIndex + 1;
				// loop through triangle numbers
				while ((count = factors.countFactors(num)) <= numDivisors) {
					num += i++;
				}
				return num;
			}
		}
	}
};

utils.logAndCheckSolutions(self);
utils.benchmarkSolutions(self);
